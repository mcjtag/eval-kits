/**
 * @file syncmaster.c
 * @brief Synchronizer driver
 * @author matyunin.d
 * @date 22.07.2019
 */

#include "syncmaster.h"
#include "xparameters.h"
#include "hmc1031.h"
#include "ad9520.h"
#include "syncron.h"

static hmc1031_dev_t hmc1031_dev;
static ad9520_dev_t ad9520_dev;
static syncron_dev_t syncron_dev;

struct ad9520_config ad9520_cfg[] = {
	{AD9520_REG_SERIAL_PORT_CONFIG,
		AD9520_SDO_ACTIVE_SDO_SDIO |
		AD9520_LSB_FIRST_ADDR_INC_MSB_DEC},
	{AD9520_REG_PFD_CHARGE_PUMP,
		AD9520_CP_CURRENT_48 |
		AD9520_CP_MODE_NORMAL |
		AD9520_PLL_POWERDOWN_ASYNC},
	{AD9520_REG_OUT0_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT1_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT2_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT3_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
		AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT4_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
	 	AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT5_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT6_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT7_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
		AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_NORMAL},
	{AD9520_REG_OUT8_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
		AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_NORMAL},
	{AD9520_REG_OUT9_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_CMOS |
		AD9520_OUT_CONTROL_CMOS_CONF_A_TRI_B_TRI |
		AD9520_OUT_CONTROL_POLARITY_A_B |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_POWER_SAFE},
	{AD9520_REG_OUT10_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
		AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_NORMAL},
	{AD9520_REG_OUT11_CONTROL,
		AD9520_OUT_CONTROL_FORMAT_LVPECL |
		AD9520_OUT_CONTROL_POLARITY_A_NOT_B |
		AD9520_OUT_CONTROL_LVPECL_DIFF_VOLT_780 |
		AD9520_OUT_CONTROL_LVPECL_POWERDOWN_NORMAL},
	{AD9520_REG_INPUT_CLKS,
		AD9520_INPUT_CLKS_CLOCK_NORMAL |
		AD9520_INPUT_CLKS_VCO_POWERDOWN |
		AD9520_INPUT_CLKS_CLOCK_VCO_NORMAL |
		AD9520_INPUT_CLKS_SELECT_CLOCK |
		AD9520_INPUT_CLKS_VCO_BYPASS_ENABLE},
	{AD9520_REG_DIVIDER_0_0,
		0x00},
	{AD9520_REG_DIVIDER_1_0,
		0x00},
	{AD9520_REG_DIVIDER_2_0,
		0x00},
	{AD9520_REG_DIVIDER_3_0,
		0x00},
	{AD9520_REG_DIVIDER_0_1,
		AD9520_REG_DIVIDER_X_1_BYPASS_ENABLE},
	{AD9520_REG_DIVIDER_1_1,
		AD9520_REG_DIVIDER_X_1_BYPASS_ENABLE},
	{AD9520_REG_DIVIDER_2_1,
		AD9520_REG_DIVIDER_X_1_BYPASS_ENABLE},
	{AD9520_REG_DIVIDER_3_1,
		AD9520_REG_DIVIDER_X_1_BYPASS_ENABLE},
	{AD9520_REG_IO_UPDATE,
		AD9520_IO_UPDATE_UPDATE},
	{-1, 0}
};

/**
 * @brief Synchronizer initialization
 * @return XST_SUCCESS | XST_FAILURE
 */
int sm_init(void)
{
	int status;

	status = hmc1031_init(&hmc1031_dev, XPAR_HMC1031_0_S_AXI_BASEADDR);
	if (status != XST_SUCCESS)
		return XST_FAILURE;

	hmc1031_divider(&hmc1031_dev, HMC1031_DIVIDER_PD);
	hmc1031_divider(&hmc1031_dev, HMC1031_DIVIDER_DIV10);

	status = ad9520_init(&ad9520_dev, XPAR_AD9520_0_S_AXI_BASEADDR);
	if (status != XST_SUCCESS)
		return XST_FAILURE;

	ad9520_ioc_reset(&ad9520_dev, AD9520_DEV_0, AD9520_ENABLE);
	ad9520_ioc_reset(&ad9520_dev, AD9520_DEV_0, AD9520_DISABLE);
	ad9520_ioc_powerdown(&ad9520_dev, AD9520_DEV_0, AD9520_ENABLE);

	if (ad9520_checkid(&ad9520_dev, AD9520_DEV_0))
		return XST_FAILURE;

	ad9520_write_config(&ad9520_dev, AD9520_DEV_0, ad9520_cfg);

	ad9520_ioc_powerdown(&ad9520_dev, AD9520_DEV_0, AD9520_DISABLE);

	status = syncron_init(&syncron_dev, XPAR_DSP_HIER_SYNCRON_0_S_AXI_BASEADDR);
	if (status != XST_SUCCESS)
		return XST_FAILURE;

	syncron_set_source(&syncron_dev, SYNCRON_SOURCE_INTERNAL);
	ad9520_ext_sync(&ad9520_dev, AD9520_ENABLE);

	return XST_SUCCESS;
}

/**
 * @brief Send syncronization pulse to clock and DSP subsystems
 * @return void
 */
void sm_sync(void)
{
	syncron_sync(&syncron_dev, SYNCRON_SYNC_CAPTURE);
}

